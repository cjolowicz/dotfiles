# -*-sh-*-

# Usage: fhelp [FUNCTION]...
# ----------------------------------------------------------------------
# Print the documentation for each FUNCTION defined in this file.
function fhelp() {
    if [ $# -eq 0 ] ; then
        sed -n -e 's/^ *# Usage: //p' -e 's/^ *//' $BASH_SOURCE | sort
    fi

    for f
    do
        sed -n -e "/^ *# Usage: $f[ \$]/,/^ *function $f/p" -e 's/^ *//' $BASH_SOURCE |
        sed -e '$d' -e 's/# //'
    done
}

# Usage: add-alias [NAME=VALUE]...
# ----------------------------------------------------------------------
# Define and save aliases to ~/.bash.d/aliases.
function add-alias() {
    for as
    do
        local name="${as%%=*}" value="${as#*=}"
        echo "alias $name='$value'" >> ~/.bash.d/aliases
        alias $name="$value"
    done
}

# Usage: wcat [FILE]...
# ----------------------------------------------------------------------
# For each FILE, find its pathname using which(1) and invoke cat(1) on
# the result.
function wcat() { cat $(which "$@"); }

# Usage: wless [FILE]...
# ----------------------------------------------------------------------
# For each FILE, find its pathname using which(1) and invoke less(1) on
# the result.
function wless() { less $(which "$@"); }

# Usage: wedit [FILE]...
# ----------------------------------------------------------------------
# For each FILE, find its pathname using which(1) and invoke edit(1) on
# the result.
function wedit() { edit $(which "$@"); }

# Usage: wldd [FILE]...
# ----------------------------------------------------------------------
# For each FILE, find its pathname using which(1) and invoke ldd(1) on
# the result.
function wldd() { ldd $(which "$@"); }

# Usage: wfile [FILE]...
# ----------------------------------------------------------------------
# For each FILE, find its pathname using which(1) and invoke file(1) on
# the result.
function wfile() { file $(which "$@"); }

# Usage: mvtr SET1 SET2 [FILE]...
# ----------------------------------------------------------------------
# Move files using tr(1).
function mvtr() {
    local set1=$1; shift
    local set2=$1; shift
    local arg= newarg=

    for arg ; do
        newarg=$(echo "$arg" | tr "$set1" "$set2")
        [ x"$arg" != x"$newarg" ] || continue
        mv "$arg" "$newarg"
    done
}

# Usage: mvsed PROG [FILE]...
# ----------------------------------------------------------------------
# Move files using sed(1).
function mvsed() {
    local prog=$1; shift
    local arg= newarg=

    for arg
    do
        newarg=$(echo "$arg" | sed "$prog")
        [ x"$arg" != x"$newarg" ] || continue
        mv "$arg" "$newarg"
    done
}

# Usage: sep [SEPARATOR = `,']
# ----------------------------------------------------------------------
# Read lines from stdin, joining them by SEPARATOR.
function sep() {
    [ $# -ne 0 ] || set ,
    sed s/\$/"$1"/ |
    xargs |
    sed s/"$1"\$//
}

# Usage: seddiff PROG [FILE]...
# ----------------------------------------------------------------------
# For each FILE, invoke sed with PROG and display the diff between input
# and output.
function seddiff() {
    local prog="$1"; shift
    local file=

    for file ; do
        sed "$prog" "$file" | diff "$file" -
    done
}

# Usage: icat
# ----------------------------------------------------------------------
# Read from stdin using gettext, printing each line to stdout.
function icat() {
    local line=

    while read -e line ; do
        echo "$line"
    done
}

# Usage: print_header [ARG]..
# ----------------------------------------------------------------------
# Print a header.
function print_header() {
    local begin= end=

    if [ -t 1 ] ; then
        set -- -C "$@"
    fi

    case $1 in -C)
        begin="$(tput setf 2)"
        end="$(tput setf 7)"
        shift
        ;;
    esac

    echo
    echo "${begin}==> $* <==${end}"
    echo
}

# Usage: vcat [FILE]...
# ----------------------------------------------------------------------
# Print each FILE preceded by its filename.
function vcat() {
    local file=

    for file ; do
        print_header "$file"
        cat "$file"
    done |
    less -RXFS
}

# Usage: columns NUM
# ----------------------------------------------------------------------
# Arrange input in NUM columns.
function columns() {
    if [ $# -eq 0 ] ; then
        column -c$(tput cols)
    else
        pr -Tw$(tput cols) -"$@"
    fi
}

# Usage: inplace [-b | --backup] FILE COMMAND [ARG]...
# ----------------------------------------------------------------------
# Modify FILE by invoking COMMAND with any ARG's given on it.
function inplace() {
    local backup=false

    case "$1" in -b | --backup)
        backup=true ; shift ;;
    esac

    if [ $# -lt 2 ] ; then
        return 1
    fi

    local file="$1" ; shift

    cp -b "$file" "$file".bak &&
    "$@" "$file".bak > "$file" &&
    $backup || rm "$file".bak
}

# Usage: realname
# ----------------------------------------------------------------------
# Print the real user name to stdout.
function realname() {
    awk -F: '( $1 == "'"$USER"'") { print $5 }' /etc/passwd | cut -d, -f1
}

# Usage: ll [FILE]..
# ----------------------------------------------------------------------
# Display a long file listing.
case $(uname) in
    Darwin)
        function ll() {
            CLICOLOR=1 CLICOLOR_FORCE=1 ls -l -h -T "$@" |
            LESS='FSRX' less
        }
        ;;

    *)
        function ll() {
            ls -l --human-readable --time-style=long-iso --color=always "$@" |
            LESS='FSRX' less
        }
        ;;
esac

if alias ll >/dev/null 2>&1 ; then unalias ll ; fi # hide the alias

# Usage: colorize REGEX
# ----------------------------------------------------------------------
# Colorize stdin writing to stdout.
function colorize() {
    if [ $# -gt 0 ] ; then
        egrep --color=always "$*|\$"
    else
        egrep --color=always .
    fi
}

case $(uname) in Darwin) ;; *)
    # Usage: penv [PID]..
    # ----------------------------------------------------------------------
    # Print the environment of the process having PID.
    function penv() {
        local pid=
        local prog=

        [ $# -gt 0 ] || set -- $$

        for pid
        do
            if [ $# -gt 1 ] ; then
                prog=$(basename $(readlink /proc/$pid/exe))
                print_header "$prog($pid)"
            fi
            tr '\0' '\n' < /proc/$pid/environ
            if [ $# -gt 1 ] ; then
                echo
            fi
        done
    }

    # Usage: pmaps [COMMAND]...
    # ----------------------------------------------------------------------
    # For each COMMAND, display the virtual memory areas of any process
    # executing it using the proc(5) file system.
    function pmaps() {
        local pid=

        for pid in $(pidof "$@") ; do
            cat /proc/$pid/maps
        done
    }

    # Usage: watchpid PID COMMAND [ARG]..
    # ----------------------------------------------------------------------
    # Execute COMMAND when process with PID has completed.
    function watchpid() {
        local pid=$1 ; shift

        while [ -e /proc/$pid ] ; do
            sleep 1
        done

        "$@"
    }
    ;;
esac

# Usage: findbroken [DIR]..
# ----------------------------------------------------------------------
# Print broken symlinks under DIR.
function findbroken() {
    local dir=

    [ $# -gt 0 ] || set -- .

    for dir ; do
        find -L "$dir" -type l -lname '*'
    done
}

# Usage: sum
# ----------------------------------------------------------------------
# Compute the sum of the numbers in stdin.
function sum() {
    local s=0 i=

    while read i ; do
        ((s+=$i))
    done

    echo $s
}

# Usage: avg
# ----------------------------------------------------------------------
# Compute the average of the numbers in stdin.
function avg() {
    local s=0 n=0 i=

    while read i ; do
        ((s+=$i))
        ((n+=1))
    done

    echo $(($s / $n))
}

# Usage: loop COMMAND [ARG]..
# ----------------------------------------------------------------------
# Repeatedly execute COMMAND and wait for a key being pressed.
function loop() {
    while : ; do
        "$@"
        read -sn1 || break
    done
}

if hash colordiff >/dev/null 2>&1 ; then
    # Usage: diffof ARG1 ARG2 COMMAND [ARG]..
    # ----------------------------------------------------------------------
    # Compare the result of invoking COMMAND on ARG1 and ARG2, respectively.
    function diffof() {
        local arg1="$1" arg2="$2" cmd="$3" ; shift 3

        colordiff --side-by-side --width=$(tput cols) \
            <("$cmd" "$@" $arg1) \
            <("$cmd" "$@" $arg2) |
        LESS='FSRX' less
    }
fi

if hash diff-view >/dev/null 2>&1 ; then
    # Usage: xdiff [ARG]..
    # ----------------------------------------------------------------------
    # Invoke hg diff and pass the output through diff-view.
    function xdiff() {
        hg diff "$@" | diff-view
    }

    # Usage: xtip [ARG]..
    # ----------------------------------------------------------------------
    # Invoke hg tip -p and pass the output through diff-view.
    function xtip() {
        hg tip -p "$@" | diff-view
    }

    # Usage: xlog [ARG]..
    # ----------------------------------------------------------------------
    # Invoke hg log -p and pass the output through diff-view.
    function xlog() {
        hg log -p "$@" | diff-view
    }
fi

# Usage: mkcd [options] DIR
# ----------------------------------------------------------------------
# Create a directory and change to it.
function mkcd() {
    mkdir "$@" && cd "${@:(-1)}"
}

if colordiff --version >/dev/null 2>&1 ; then
    # Usage: diff [options]
    # ----------------------------------------------------------------------
    # Invoke diff. If stdin is a terminal, colorize and page the output.
    function diff() {
        if [ -t 1 ] ; then
            (
                set -o pipefail
                colordiff -u "$@" | LESS='FSRX' less
            )
        else
            command diff -u "$@"
        fi
    }
fi

# Usage: history [options]
# ----------------------------------------------------------------------
# Display the bash history.
function history() {
    builtin history "$@" | LESS=FSX less
}
